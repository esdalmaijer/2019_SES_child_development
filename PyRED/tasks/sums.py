import os
import copy
import time

import numpy

from PyRED.files import read_behaviour
from PyRED.tasks.generic import TaskLoader


class SumsLoader(TaskLoader):
    
    """Class to process files from the RED Sums task.
    """
    
    def __init__(self, data_dir, output_path=None, task_name="SumsTest"):
        
        """Initialises a new ReadingLoader instance to read and process data
        from files generated by the RED reading task.
        
        Arguments
        
        data_dir            -   String. Path to the directory that contains
                                data files that need to be loaded.

        Keyword Arguments
        
        output_path         -   String. Path to the file in which processed
                                data needs to be stored, or None to not write
                                the data to file. Default = None

        task_name           -   String. Name of the task that needs to be
                                present in the data files. The names of data
                                files are assumed to be in the format
                                "taskname_ppname_yyyy-mm-dd-HH-MM-SS"
                                Default = "SumsTest"

        """
        
        # Load all data.
        self.load_from_directory(data_dir, task_name)
        self.process_raw_data()
        if not (output_path is None):
            self.write_processed_data_to_file(output_path)

    

    def load_from_file(self, file_path, delimiter=",", missing=None, \
            auto_typing=True, string_vars=None):
        
        """Loads data from a single file. This function overwrites the parent's
        load_from_file function to allow for the checking of answers.

        Arguments
        
        file_path       -   String. Path to the file that needs to be loaded.
        
        Keyword arguments
        
        delimiter       -   String. Delimiter for the data file. Default = ","
        
        missing         -   List. List of values that code for missing data, or
                            None if no such values exist. Note that all values
                            should be strings, as this is what the data will
                            initially be read as (missing data is converted before
                            auto-typing occurs). Default = None.
        
        auto_typing     -   Bool. When True, variables will automatically be
                            converted to float where possible. Default = True
        
        Returns
        
        data            -   Whatever PyRED.files.read_behaviour returns.
        """
        
        # Load the data from a file.
        raw = read_behaviour(file_path, delimiter=",", missing=None, \
            auto_typing=True, string_vars=["Sum", "Response"])
        
        # If the file is empty, return None.
        if raw is None:
            return None
        
        # Compute the response times for each trial.
        raw["RT"] = numpy.zeros(raw["Time"].shape, dtype=float)
        raw["RT"][0] = raw["Time"][0]
        raw["RT"][1:] = numpy.diff(raw["Time"])
        
        # Go through the answers to check whether they are correct.
        raw["correct"] = numpy.zeros(raw["Response"].shape, dtype=bool)
        for i, sum_item in enumerate(raw["Sum"]):

            # Basic checks on the sum to make sure we don't eval some bad code.
            sum_ok = True
            if sum_item.count(' ') != 2:
                sum_ok = False
            if len(sum_item) not in [5, 6, 7]:
                sum_ok = False
            first, operator, second = sum_item.split(' ')
            try: first = int(first)
            except: sum_ok = False
            try: second = int(second)
            except: sum_ok = False
            if operator not in ['+', '-', 'x']:
                sum_ok = False
            # Manually check if the sum is OK to evaluate.
            if not sum_ok:
                print("\tThe following sum did not pass the automatic checks:\n")
                print(sum_item)
                time.sleep(1.0)
                print('\n')
                resp = ''
                while resp not in ['y', 'n']:
                    resp = raw_input("Evaluate this sum anyway? (y/n) ")
                if resp == 'y':
                    time.sleep(0.5)
                    resp = ''
                    while resp not in ['y', 'n']:
                        resp = raw_input("Are you sure you want to evaluate the code? Doing so could mess up your computer! (y/n) ")
                    sum_ok = resp == 'y'
            # Replace any 'x' with a '*', to make multiplication work.
            sum_item = sum_item.replace('x', '*')
            # Evaluate the sum to find the correct answer.
            if sum_ok:
                # TODO: Using 'eval' on strings that aren't checked is risky!
                # Maybe we shouldn't do it like this?
                answer = eval(sum_item)
            else:
                answer = 'unknown'

            # Check and store whether the response was correct.
            raw["correct"][i] = raw["Response"][i] == str(answer)
        
        return raw
    
    
    def process_raw_data(self):
        
        """Computes the variables that need to be computed from this task, and
        stores them in the self.data dict. This has one key for every variable
        of interest, and each of these keys points to a NumPy array with shape
        (N,) where N is the number of participants.
        
        The processed data comes from the self.raw dict, so make sure that
        self.load_from_directory is run before this function is.
        """
        
        # Define some variables of interest.
        vor = ["n_sums", "n_correct", "p_correct", "median_RT", \
            "mean_RT", "stdev_RT", "scaled_stdev_RT"]
        
        # Get all participant names, or return straight away if no data was
        # loaded yet.
        if hasattr(self, "raw"):
            participants = self.raw.keys()
            participants.sort()
        else:
            self.data = None
            return

        # Count the number of participants.
        n = len(participants)
        
        # Create a data dict for each variable of interest.
        self.data = {}
        self.data["ppname"] = []
        for var in vor:
            self.data[var] = numpy.zeros(n, dtype=float) * numpy.NaN
        
        # Loop through all participants.
        for i, ppname in enumerate(participants):
            # Add the participant name.
            self.data["ppname"].append(copy.deepcopy(ppname))
            # Skip empty datasets.
            if self.raw[ppname] is None:
                continue
            # Compute stuff relevant to this task.
            self.data["n_sums"][i] = len(self.raw[ppname]["Sum"])
            self.data["n_correct"][i]   = numpy.sum(self.raw[ppname]["correct"])
            self.data["p_correct"][i]   = float(self.data["n_correct"][i]) \
                / float(self.data["n_sums"][i])
            self.data["median_RT"][i]   = numpy.nanmedian(self.raw[ppname]["RT"])
            self.data["mean_RT"][i]     = numpy.nanmean(self.raw[ppname]["RT"])
            self.data["stdev_RT"][i]    = numpy.nanstd(self.raw[ppname]["RT"])
        # Compute a scaled standard deviation of the response time, scaled to the
        # median response time to remove the correlation between the two.
        self.data["scaled_stdev_RT"] = self.data["stdev_RT"] / self.data["median_RT"]
