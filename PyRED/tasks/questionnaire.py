import os
import copy
import time

import numpy

from PyRED.files import read_behaviour
from PyRED.tasks.generic import TaskLoader


class QuestionnaireLoader(TaskLoader):
    
    """Class to process files from the RED questionnaires.
    """
    
    def __init__(self, data_dir, output_path=None, task_name="Q1_Questions"):
        
        """Initialises a new QuestionnaireLoader instance to read and process
        data from files generated by the RED questionnaires.
        
        Arguments
        
        data_dir            -   String. Path to the directory that contains
                                data files that need to be loaded.

        Keyword Arguments
        
        output_path         -   String. Path to the file in which processed
                                data needs to be stored, or None to not write
                                the data to file. Default = None

        task_name           -   String. Name of the task that needs to be
                                present in the data files. The names of data
                                files are assumed to be in the format
                                "taskname_ppname_yyyy-mm-dd-HH-MM-SS"
                                Default = "Q1_Questions"

        """
        
        # Remember the task name.
        self._task_name = task_name
        # Load all data.
        self.load_from_directory(data_dir, task_name)
        self.process_raw_data()
        if not (output_path is None):
            self.write_processed_data_to_file(output_path)


    def load_from_file(self, file_path, delimiter=",", missing=None, \
            auto_typing=True, string_vars=None):
        
        """Loads data from a single file. This function overwrites the parent's
        load_from_file function to allow for the checking of answers.

        Arguments
        
        file_path       -   String. Path to the file that needs to be loaded.
        
        Keyword arguments
        
        delimiter       -   String. Delimiter for the data file. Default = ","
        
        missing         -   List. List of values that code for missing data, or
                            None if no such values exist. Note that all values
                            should be strings, as this is what the data will
                            initially be read as (missing data is converted before
                            auto-typing occurs). Default = None.
        
        auto_typing     -   Bool. When True, variables will automatically be
                            converted to float where possible. Default = True
        
        Returns
        
        data            -   Whatever PyRED.files.read_behaviour returns.
        """
        
        # Load the data from a file.
        raw = read_behaviour(file_path, delimiter=",", missing=None, \
            auto_typing=True, string_vars=["Response"])
        
        # If the file is empty, return None.
        if raw is None:
            return None
        
        return raw
    
    
    def process_raw_data(self):
        
        """Computes the variables that need to be computed from this task, and
        stores them in the self.data dict. This has one key for every variable
        of interest, and each of these keys points to a NumPy array with shape
        (N,) where N is the number of participants.
        
        The processed data comes from the self.raw dict, so make sure that
        self.load_from_directory is run before this function is.
        """
        
        # Get all participant names, or return straight away if no data was
        # loaded yet.
        if hasattr(self, "raw"):
            participants = self.raw.keys()
            participants.sort()
        else:
            self.data = None
            return

        # Count the number of participants.
        n = len(participants)
        
        # Find out how many questions there were.
        n_questions = 0
        for i, ppname in enumerate(participants):
            if self.raw[ppname] is None:
                continue
            if len(self.raw[ppname]["QuestionNumber"]) > n_questions:
                n_questions = len(self.raw[ppname]["QuestionNumber"])
        
        # Define some variables of interest.
        vor = []
        for i in range(n_questions):
            vor.append("Q%d_resp" % (i+1))
            vor.append("Q%d_RT" % (i+1))
        
        # Create a data dict for each variable of interest.
        self.data = {}
        self.data["ppname"] = []
        for var in vor:
            self.data[var] = numpy.zeros(n, dtype=float) * numpy.NaN
        
        # Loop through all participants.
        for i, ppname in enumerate(participants):
            # Add the participant name.
            self.data["ppname"].append(copy.deepcopy(ppname))
            # Skip empty datasets.
            if self.raw[ppname] is None:
                continue
            # Compute stuff relevant to this task.
            for j, qnr in enumerate(self.raw[ppname]["QuestionNumber"]):
                # Split Questionnaire 3, Q13 and Q14 into sub-questions
                if "Q3" in self._task_name and int(qnr) in [13,14]:
                    # These questions split out into two parts: A description
                    # of what each sub-part is, and a Boolean response for
                    # each sub-part in the question. Example:
                    # "1_1_1_1_1_0//Television_VideogameConsole(suchas:WiiUPlayStationXboxorNintendoDS)_Tablet(likeanIPad)_Smartphone_LaptoporDesktopComputer_Noneofthese"
                    bool_resp, descr = self.raw[ppname]["Response"][j].split("//")
                    bool_resp = map(int, bool_resp.split("_"))
                    descr = descr.split("_")
                    # Store the data in the dict.
                    for k, item in enumerate(descr):
                        # Clean up the item name.
                        if "(" in item:
                            item = item[:item.find("(")]
                        var = "Q%s_%s_resp" % (int(qnr), item)
                        # Create a new entry in the dict for this variable, if
                        # one doesn't exist yet.
                        if var not in self.data.keys():
                            self.data[var] = numpy.zeros(n, dtype=float) * numpy.NaN
                        # Store the data in the dict.
                        self.data[var][i] = bool_resp[k]
                    # Store response time for the whole item.
                    self.data["Q%s_RT" % (int(qnr))][i] = \
                        float(self.raw[ppname]["TimeEndQuestion"][j]) \
                        - float(self.raw[ppname]["TimeStartQuestion"][j])
                # All other questions are one-question one-response:
                else:
                    # Store the data in the dict.
                    self.data["Q%s_resp" % (int(qnr))][i] = \
                        float(self.raw[ppname]["Response"][j])
                    self.data["Q%s_RT" % (int(qnr))][i] = \
                        self.raw[ppname]["TimeEndQuestion"][j] \
                        - self.raw[ppname]["TimeStartQuestion"][j]
